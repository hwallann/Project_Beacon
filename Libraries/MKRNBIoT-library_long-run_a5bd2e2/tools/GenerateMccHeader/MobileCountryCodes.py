from csv import DictWriter
from io import StringIO

from datetime import datetime

from operator import itemgetter
from itertools import groupby

from bs4 import element


def parse_operators(operators_tag) -> list:
    rows = operators_tag.find_all('tr')[1:]
    operators = []

    for row in rows:
        tds = row.find_all('td')
        mcc, mnc, brand, operator, status, _, _ = [''.join(td.strings) for td in tds]

        if mcc == 'Unknown' or mnc == 'Unknown' or status != 'Operational':
            continue

        operator = operator if operator else 'Unknown'
        brand = brand if brand else 'Unknown'

        operators.append({
            'MCC': mcc.title(),
            'MNC': mnc.title(),
            'Brand': brand.title(),
            'Operator': operator.title()
        })

    return operators


def parse_table(table_tag) -> list:
    operators_table = table_tag.find_next('table', {'class': 'wikitable'})

    return parse_operators(operators_table)


def parse_nation(nation_tag):
    nation = nation_tag.a.string
    iso = nation_tag.find_all('span', {'class': 'mw-headline'})[0]['id'].split('_-_')[1]

    operators = parse_table(nation_tag)
    for op in operators:
        op['Nation'] = nation
        op['ISO'] = iso

    return operators


def parse_international(international_tag):
    nation = international_tag.span['id']

    operators = parse_table(international_tag)
    for op in operators:
        op['Nation'] = nation
        op['ISO'] = "00"

    return operators


def generate_csv(table):
    fieldnames = table[0].keys()
    csv_file = StringIO()

    writer = DictWriter(csv_file, fieldnames=fieldnames)
    writer.writeheader()
    writer.writerows(table)

    return csv_file.getvalue()


def table_to_map(table):
    countries = {}
    # TODO: GroupBy ISO
    for (mcc, nation, iso), operators in groupby(table, key=itemgetter('MCC', 'Nation', 'ISO')):
        countries[iso] = {
            'nation': nation,
            'iso': iso,
            'mcc': mcc,
            'operators': []
        }
        for op in operators:
            operator = {
                'mnc': op['MNC'],
                'brand': op['Brand']
            }
            countries[iso]['operators'].append(operator)
    return countries


def generate_cpp_header(table):
    countries = table_to_map(table)

    header = """/*

  NB-IoT / LTE-M Mobile Country Codes for Arduino.

  This file is partially autogenerated from
  * https://en.wikipedia.org/wiki/Mobile_country_code
  * https://www.gsma.com/iot/mobile-iot-commercial-launches

  If your operator is missing, please, contact <>

  Created {}'
  by RetrievePLMNs.py

*/"""

    contents = list()

    contents.append(header.format(datetime.now()))

    contents.append("""
struct MobileOperator {
  const char* MNC;
  const char* Brand;
};""")

    contents.append("""
struct MobileCountry {
  const char* ISO;
  const char* MCC;
  const int OperatorsNum;
  const MobileOperator *Operators;
  const char* Nation;
};
""")

    jnr = ',\n'

    # TODO: Generate structs by ISO Country Code
    for k, v in countries.items():
        contents.append(f'MobileOperator Operators_{k}[] = {{')
        operators = [f'  {{\"{operator["mnc"]}\", \"{operator["brand"]}\"}}' for operator in v['operators']]
        contents.append(jnr.join(operators))
        contents.append('};\n')

    contents.append('#define _LEN(X) sizeof(X) / sizeof(MobileOperator)\n')

    contents.append('MobileCountry MCCs[] = {')
    nations = [
        f'  {{\"{k}\", \"{v["mcc"]}\", _LEN(Operators_{k}), Operators_{k}, \"{v["nation"]}\"}}'
        for k, v in countries.items()
    ]
    contents.append(jnr.join(nations))
    contents.append('};\n')
    contents.append(f'const int MCCs_NUM = sizeof(MCCs) / sizeof(MobileCountry);\n')

    return '\n'.join(contents)


def generate_table(html):
    table = []

    nations_tag = html.find_all('h4')
    for nation_tag in nations_tag:
        for operator in parse_nation(nation_tag):
            table.append(operator)

    last_nation = nations_tag[-1]
    international_tag = last_nation.find_all_next('h2')[0]
    for operator in parse_international(international_tag):
        table.append(operator)

    return table
